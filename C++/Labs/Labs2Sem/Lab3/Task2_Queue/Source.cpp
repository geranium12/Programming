/*
	Герасимчик Анна. 1 курс. 7 группа

	Условие:
	Реализуйте структуру данных "очередь". Напишите программу, содержащую описание очереди и 
	моделирующую работу очереди, реализовав все указанные здесь методы.  Программа считывает 
	последовательность команд и в зависимости от команды выполняет ту или иную операцию. 
	После выполнения каждой команды программа должна вывести одну строчку. Возможные команды 
	для программы:

	push n
	Добавить в очередь число n (значение n задается после команды). Программа должна вывести ok. 
	pop
	Удалить из очереди первый элемент. Программа должна вывести его значение. 
	front
	Программа должна вывести значение первого элемента, не удаляя его из очереди. 
	size
	Программа должна вывести количество элементов в очереди. 
	clear
	Программа должна очистить очередь и вывести ok. 
	exit
	Программа должна вывести bye и завершить работу.
	Перед исполнением операций front и pop программа должна проверять, содержится ли в очереди 
	хотя бы один элемент. Если во входных данных встречается операция front или pop, и при этом
	очередь пуста, то программа должна вместо числового значения вывести строку  error.
		
	Входные данные
	Вводятся команды управления очередью, по одной на строке
	Выходные данные
	Требуется вывести протокол работы очереди, по одному сообщению на строке
	
	Решение:
	Напишем свой стандартный класс очередь с заданными выше функциями.

	Примеры
	входные данные
	push 1
	front
	exit
	выходные данные
	ok
	1
	bye
	входные данные
	size
	push 1
	size
	push 2
	size
	push 3
	size
	exit
	выходные данные
	0
	ok
	1
	ok
	2
	ok
	3
	bye
*/

#include "Queue.h"
#include <string>
#include <iostream>

using namespace std;

int main()
{
	setlocale(LC_ALL, ".1251");
	Queue q;
	string str;
	cout << "Введите команды для работы с очередью (читать условие задачи в файле Source.cpp" << endl;
	while (str != "exit")
	{
		cin >> str;
		if (str == "push")
		{
			int x;
			cin >> x;
			q.push_back(x);
			cout << "ok" << endl;
		}
		else
		{
			if (str == "front")
			{
				if (q.isEmpty())
				{
					cout << "error" << endl;
				}
				else
				{
					cout << q.front() << endl;
				}
			}
			else
			{
				if (str == "size")
				{
					cout << q.size() << endl;
				}
				else
				{
					if (str == "pop")
					{
						if (q.isEmpty())
						{
							cout << "error" << endl;
						}
						else
						{
							cout << q.front() << endl;
							q.pop_front();
						}
					}
					else
					{
						if (str == "clear")
						{
							q.clear();
							cout << "ok" << endl;
						}
						else
						{
							cout << "bye" << endl;
						}
					}
				}
			}
		}
	}
	system("pause");
	return 0;
}